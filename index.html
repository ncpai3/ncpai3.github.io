<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- 1. New Title -->
<title>CÔNG PHÚC ĐẸP TRAI MAY MẮN PHÁT TÀI 6868</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<style>
    body {
        font-family: 'Inter', sans-serif;
        background-color: #111827; /* Tailwind gray-900 */
        color: #F9FAFB; /* Tailwind gray-50 */
    }
    .btn {
        transition: all 0.3s ease;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }
    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }
    .btn:active {
        transform: translateY(1px);
    }
    .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    /* Removed unused card glow styles */
    #bigRoadDisplay {
        display: grid;
        grid-auto-flow: column;
        grid-auto-columns: 2.5rem; /* 40px */
        gap: 2px;
        overflow-x: auto;
        padding: 8px;
        scrollbar-width: thin;
        scrollbar-color: #4B5563 #1F2937;
    }
    .road-col {
        display: grid;
        grid-auto-rows: 2.5rem; /* 40px */
        gap: 2px;
    }
    .road-item {
        width: 2.5rem; height: 2.5rem; border-radius: 9999px;
        display: flex; align-items: center; justify-content: center;
        font-weight: bold; font-size: 1.125rem; color: white;
        animation: fadeIn 0.5s ease;
    }
    @keyframes fadeIn {
        from { opacity: 0; transform: scale(0.8); }
        to { opacity: 1; transform: scale(1); }
    }
    /* Modal and Toast styles */
    .modal-backdrop {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background-color: rgba(0,0,0,0.7);
        display: flex; align-items: center; justify-content: center;
        z-index: 50; animation: fadeIn 0.3s ease;
    }
    .modal-content {
        background-color: #1f2937; /* gray-800 */
        padding: 1.5rem; border-radius: 1rem;
        width: 90%; max-width: 400px;
        animation: slideIn 0.3s ease-out;
        border: 1px solid #374151; /* gray-700 */
    }
    .toast-notification {
        position: fixed; top: 20px; right: 20px;
        background-color: #1f2937; color: white;
        padding: 1rem 1.5rem; border-radius: 0.5rem;
        box-shadow: 0 10px 15px -3px rgba(0,0,0,0.3);
        z-index: 100; animation: slideDown 0.5s ease;
        border-left: 4px solid;
    }
    @keyframes slideIn {
        from { opacity: 0; transform: translateY(-20px) scale(0.95); }
        to { opacity: 1; transform: translateY(0) scale(1); }
    }
    @keyframes slideDown {
        from { opacity: 0; transform: translateY(-100%); }
        to { opacity: 1; transform: translateY(0); }
    }
    #sessionManagementContent {
        transition: max-height 0.5s ease-in-out;
        overflow: hidden;
    }
    @keyframes fadeOut {
        from { opacity: 1; transform: translateY(0); }
        to { opacity: 0; transform: translateY(-20px); }
    }
    /* History Chart Styles (shared by all 3 Chot panels) */
    .history-chart {
        display: flex;
        align-items: flex-end;
        justify-content: center;
        gap: 1px;
        height: 40px;
        padding: 5px 0;
        overflow: hidden;
    }
    .history-bar {
        flex-shrink: 0;
        width: 3px;
        border-radius: 1px;
    }
    .history-bar-correct {
        background-color: #3b82f6; /* Blue-500 */
        height: 100%;
    }
    .history-bar-incorrect {
        background-color: #ef4444; /* Red-500 */
        height: 40%;
    }
    /* Simple divider style */
    .system-divider {
        border-top: 2px dashed #4b5563; /* gray-600 */
        margin-top: 1.5rem;
        margin-bottom: 1.5rem;
    }
</style>
</head>
<body class="p-4 md:p-8">
<div id="modal-container"></div>
<div id="toast-container"></div>

<div class="max-w-7xl mx-auto space-y-6">

    <!-- Header -->
    <div class="bg-gray-800 p-6 rounded-2xl shadow-lg text-center">
        <!-- 1. New Title -->
        <h1 class="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 via-pink-500 to-purple-500">
            CÔNG PHÚC ĐẸP TRAI MAY MẮN PHÁT TÀI 6868
        </h1>
        <p class="text-gray-400 mt-2">Ghi nhớ - Đối chiếu - Phán đoán (3 Hệ Thống)</p>
    </div>

    <!-- 2. Shared Session Management -->
    <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
        <div class="flex justify-between items-center cursor-pointer" onclick="toggleSessionManagement()">
            <h2 class="text-xl font-semibold text-blue-300">📁 Quản Lý Phiên Chung</h2>
            <button id="toggleSessionBtn" class="text-gray-400 hover:text-white p-1">
                <svg id="toggleSessionIcon" class="w-6 h-6 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
            </button>
        </div>
        <div id="sessionManagementContent">
            <div class="mt-4">
                <div class="flex flex-col sm:flex-row gap-4 mb-2">
                    <select id="sessionSelector" multiple size="5" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"></select>
                    <div class="grid grid-cols-2 gap-4">
                        <button onclick="createNewSession()" class="btn w-full bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-4 rounded-lg">➕ Mới</button>
                        <button onclick="renameSession()" class="btn w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-4 rounded-lg">✏️ Đổi Tên</button>
                        <button onclick="deleteSelectedSessions()" class="btn w-full bg-red-600 hover:bg-red-500 text-white font-bold py-3 px-4 rounded-lg col-span-2">🗑️ Xóa Mục Đã Chọn</button>
                        <button onclick="deleteAllSessions()" class="btn w-full bg-red-800 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg col-span-2">💥 Xóa Tất Cả</button>
                    </div>
                </div>
                <p class="text-xs text-gray-500 text-center mb-4 sm:text-left">Mẹo: Giữ phím Shift hoặc Ctrl (Cmd trên Mac) để chọn nhiều phiên.</p>
                <div class="flex flex-col sm:flex-row gap-4">
                    <button onclick="exportData()" class="btn w-full bg-sky-600 hover:bg-sky-500 text-white font-bold py-3 px-4 rounded-lg">📤 Xuất Lịch Sử</button>
                    <button onclick="document.getElementById('fileInput').click()" class="btn w-full bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-4 rounded-lg">📥 Nhập Lịch Sử</button>
                    <input type="file" id="fileInput" class="hidden" accept=".json" onchange="importData(event)">
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content Grid -->
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

        <!-- Left Column: Input & Shared Big Road -->
        <div class="lg:col-span-1 space-y-6">
            <!-- Input Section -->
            <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                <h2 class="text-xl font-semibold mb-4 text-blue-300">🎲 Nhập Kết Quả Ván Hiện Tại</h2>
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <button onclick="addResult('P')" class="btn bg-blue-600 hover:bg-blue-500 text-white font-bold py-6 rounded-lg text-2xl"><span>👤</span> P</button>
                    <button onclick="addResult('B')" class="btn bg-red-600 hover:bg-red-500 text-white font-bold py-6 rounded-lg text-2xl"><span>🏦</span> B</button>
                </div>
                <div class="flex gap-4">
                    <button onclick="undoLast()" class="btn flex-1 bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg">↩️ Hoàn Tác</button>
                    <button onclick="showCustomConfirm('Bạn có chắc muốn xóa toàn bộ lịch sử và thống kê của phiên này không?', clearCurrentSessionHistory)" class="btn flex-1 bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg">🗑️ Xóa Lịch Sử</button>
        _       </div>
            </div>

            <!-- 2. Shared Big Road Display -->
            <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-semibold text-blue-300">📜 Bảng Cầu Big Road Chung</h2>
                    <span class="text-gray-400 font-medium">Tổng: <span id="totalGames">0</span> ván</span>
                </div>
                <div class="bg-gray-900 rounded-lg min-h-[280px] border border-gray-700">
                    <div id="bigRoadDisplay">
                        <p class="text-gray-500 p-4">Chưa có kết quả...</p>
                    </div>
                </div>
            </div>
             <!-- Shared Accuracy Stats (Reflecting System 1 for simplicity) -->
             <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                <h2 class="text-xl font-semibold mb-4 text-green-300">🎯 Thống Kê HT1 (Phiên)</h2>
                <div class="space-y-4">
                    <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
                        <span class="font-medium text-gray-300">Tỷ Lệ Thắng HT1</span>
                        <span id="accuracyRate" class="text-2xl font-bold text-green-400">0.0%</span>
                    </div>
                    <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
                        <span class="font-medium text-gray-300">Thắng / Tổng HT1</span>
                        <div><span id="correctPredictions" class="text-lg font-semibold text-white">0</span><span class="text-gray-400">/</span><span id="totalPredictions" class="text-lg font-semibold text-white">0</span></div>
                    </div>
                </div>
            </div>
            <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                <h2 class="text-xl font-semibold mb-4 text-cyan-300">🌐 Thống Kê HT1 (Toàn Cục)</h2>
                <div class="space-y-4">
                    <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
ci                       <span class="font-medium text-gray-300">Tỷ Lệ Thắng HT1</span>
                        <span id="globalAccuracyRate" class="text-2xl font-bold text-cyan-400">0.0%</span>
                    </div>
                    <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg">
                        <span class="font-medium text-gray-300">Thắng / Tổng HT1</span>
                        <div><span id="globalCorrectPredictions" class="text-lg font-semibold text-white">0</span><span class="text-gray-400">/</span><span id="globalTotalPredictions" class="text-lg font-semibold text-white">0</span></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Column: Combined Chot Panels -->
        <div class="lg:col-span-2 space-y-6">

            <!-- 3. Combined Chot Analysis Panels Container -->
            <div class="bg-gray-800 p-6 rounded-2xl shadow-lg">
                <h2 class="text-2xl font-bold mb-6 text-center text-purple-300">🔐🔐🔐 Bảng Chốt Phán Quyết Tổng Hợp 🔐🔐🔐</h2>

                <!-- Chot Panel for System 1 -->
                <div id="chotAnalysisPanel1" class="mb-6">
                    <h3 class="text-xl font-semibold mb-4 text-purple-400 border-b-2 border-purple-600 pb-2">Hệ Thống 1 (10-20)</h3>
                    <div id="finalChotResult1" class="text-center bg-gray-900 py-3 rounded-lg border-2 border-purple-500 mb-4 transition-all duration-300">
                        <p class="text-sm text-gray-400 mb-1">Đề xuất "CHỐT" HT1:</p>
                        <p id="finalChotResultText1" class="text-xl font-extrabold text-gray-400">... Chờ tín hiệu ...</p>
                    </div>
                    <div id="chotAnalysisDetails1" class="space-y-1 text-xs">
                        <p class="text-gray-500 text-center py-2">Đang tải phân tích HT1...</p>
            _       </div>
                    <div class="bg-gray-900 rounded-lg p-2 mt-3">
                        <div class="flex justify-between items-center mb-1 px-1">
                            <span class="text-xs font-medium text-gray-400">Lịch sử Chốt HT1 (Max 50):</span>
                            <span id="chotAccuracyStats1" class="text-xs font-semibold text-gray-300">Đ: 0/0 (0.0%)</span>
                        </div>
                        <div id="chotHistoryChart1" class="history-chart">
                             <p class="text-gray-600 text-xs text-center w-full">Chưa có LS Chốt HT1...</p>
                        </div>
                    </div>
                </div>

                <div class="system-divider"></div> <!-- Divider -->

                <!-- Chot Panel for System 2 -->
                <div id="chotAnalysisPanel2" class="mb-6">
                     <h3 class="text-xl font-semibold mb-4 text-teal-400 border-b-2 border-teal-600 pb-2">Hệ Thống 2 (10-15)</h3>
                     <div id="finalChotResult2" class="text-center bg-gray-900 py-3 rounded-lg border-2 border-teal-500 mb-4 transition-all duration-300">
                        <p class="text-sm text-gray-400 mb-1">Đề xuất "CHỐT" HT2:</p>
                        <p id="finalChotResultText2" class="text-xl font-extrabold text-gray-400">... Chờ tín hiệu ...</p>
                    </div>
                    <div id="chotAnalysisDetails2" class="space-y-1 text-xs">
                         <p class="text-gray-500 text-center py-2">Đang tải phân tích HT2...</p>
                    </div>
              _       <div class="bg-gray-900 rounded-lg p-2 mt-3">
                        <div class="flex justify-between items-center mb-1 px-1">
                            <span class="text-xs font-medium text-gray-400">Lịch sử Chốt HT2 (Max 50):</span>
                            <span id="chotAccuracyStats2" class="text-xs font-semibold text-gray-300">Đ: 0/0 (0.0%)</span>
                      _ </div>
                        <div id="chotHistoryChart2" class="history-chart">
                            <p class="text-gray-600 text-xs text-center w-full">Chưa có LS Chốt HT2...</p>
                        </div>
                    </div>
                </div>

                 <div class="system-divider"></div> <!-- Divider -->

                 <!-- Chot Panel for System 3 -->
                 <div id="chotAnalysisPanel3">
                      <h3 class="text-xl font-semibold mb-4 text-rose-400 border-b-2 border-rose-600 pb-2">Hệ Thống 3 (10-20)</h3>
                      <div id="finalChotResult3" class="text-center bg-gray-900 py-3 rounded-lg border-2 border-rose-500 mb-4 transition-all duration-300">
                        <p class="text-sm text-gray-400 mb-1">Đề xuất "CHỐT" HT3:</p>
                        <p id="finalChotResultText3" class="text-xl font-extrabold text-gray-400">... Chờ tín hiệu ...</p>
                    </div>
                    <div id="chotAnalysisDetails3" class="space-y-1 text-xs">
                        <p class="text-gray-500 text-center py-2">Đang tải phân tích HT3...</p>
                    </div>
                    <div class="bg-gray-900 rounded-lg p-2 mt-3">
                        <div class="flex justify-between items-center mb-1 px-1">
                            <span class="text-xs font-medium text-gray-400">Lịch sử Chốt HT3 (Max 50):</span>
                            <span id="chotAccuracyStats3" class="text-xs font-semibold text-gray-300">Đ: 0/0 (0.0%)</span>
             _         </div>
      _               <div id="chotHistoryChart3" class="history-chart">
Ci                         <p class="text-gray-600 text-xs text-center w-full">Chưa có LS Chốt HT3...</p>
                        </div>
                    </div>
                </div>
            </div> <!-- End Combined Chot Panels Container -->

            <!-- 4. Hidden Sections (Removed from HTML for clarity) -->
            <!-- Verdict Stats Table (Hidden) -->
            <!-- Confidence Stats Table (Hidden) -->
            <!-- Original Pattern Analysis Card (Hidden/Replaced by Chot) -->

        </div> <!-- End Right Column -->
    </div> <!-- End Main Content Grid -->
</div> <!-- End Max Width Container -->

<script>
// --- GLOBAL CONSTANTS ---
const CHOT_SOURCES = ['follow', 'against', '90-100', '80-90', '70-80', '60-70', '50-60'];
const CONFIDENCE_RANGES = [
    { key: '50-60', min: 50, max: 60 }, { key: '60-70', min: 60, max: 70 },
    { key: '70-80', min: 70, max: 80 }, { key: '80-90', min: 80, max: 90 },
    { key: '90-100', min: 90, max: 100.1 } // Use 100.1 to include 100
];

// --- CORE LOGIC: PATTERN MATCHER (Accepts config) ---
class PatternMatcher {
    // Modified constructor to accept lengths
    constructor(minPatternLength = 10, maxPatternLength = 20) {
        this.MIN_HISTORY_FOR_ANALYSIS = 10;
        this.MIN_PATTERN_LENGTH = minPatternLength;
        this.MAX_PATTERN_LENGTH = maxPatternLength;
        this.MIN_CERTAIN_OCCURRENCES = 5; // Keep this consistent for now
        // console.log(`Matcher created with MIN: ${this.MIN_PATTERN_LENGTH}, MAX: ${this.MAX_PATTERN_LENGTH}`);
    }

    calculateSimilarity(arr1, arr2) {
        if (arr1.length !== arr2.length || arr1.length === 0) return 0;
        const matches = arr1.filter((item, index) => item === arr2[index]).length;
        return matches / arr1.length;
    }

    findPatternOccurrences(pattern, allHistory) {
        const occurrences = [];
        const reversedPattern = [...pattern].reverse();
        for (const sessionId in allHistory) { // Iterate through sessions object
            const session = allHistory[sessionId];
            const sessionHistory = session.history || [];
            if (sessionHistory.length < pattern.length + 1) continue;
            for (let i = 0; i <= sessionHistory.length - pattern.length - 1; i++) {
                const segment = sessionHistory.slice(i, i + pattern.length);
                const nextResult = sessionHistory[i + pattern.length];

                const similarity = this.calculateSimilarity(pattern, segment);
                if (similarity >= 0.9) occurrences.push({ type: 'similar', next: nextResult, similarity });

                const reverseSimilarity = this.calculateSimilarity(reversedPattern, segment);
                if (reverseSimilarity >= 0.9) occurrences.push({ type: 'reversed', next: nextResult, similarity: reverseSimilarity });
            }
        }
        return occurrences;
    }

     getPredictionForPattern(pattern, allHistoricalSessions) {
        const occurrences = this.findPatternOccurrences(pattern, allHistoricalSessions);
        if (occurrences.length === 0) return { prediction: null };

        const votes = { P: 0, B: 0 };
        occurrences.forEach(match => { if (votes[match.next] !== undefined) votes[match.next] += match.similarity; });

        const totalVotes = votes.P + votes.B;
        if (totalVotes === 0) return { prediction: null };

        const predictedWinner = votes.P > votes.B ? 'P' : 'B';
        const confidence = (Math.max(votes.P, votes.B) / totalVotes) * 100;

        return { prediction: predictedWinner, confidence, votes, totalOccurrences: occurrences.length };
    }

    findCertainPrediction(currentHistory, allHistoricalSessions) {
        for (let len = Math.min(this.MAX_PATTERN_LENGTH, currentHistory.length); len >= this.MIN_PATTERN_LENGTH; len--) {
            const pattern = currentHistory.slice(-len);
            const patternString = pattern.join('');
            const occurrences = [];

            for (const sessionId in allHistoricalSessions) { // Iterate through sessions object
                const session = allHistoricalSessions[sessionId];
                const sessionHistory = session.history || [];
                if (sessionHistory.length < pattern.length + 1) continue;
                for (let i = 0; i <= sessionHistory.length - pattern.length - 1; i++) {
                    const segment = sessionHistory.slice(i, i + pattern.length);
                    if (segment.join('') === patternString) {
                        occurrences.push(sessionHistory[i + pattern.length]);
                    }
                }
            }

            if (occurrences.length >= this.MIN_CERTAIN_OCCURRENCES && new Set(occurrences).size === 1) {
                return {
                    prediction: occurrences[0],
                    recommendation: 'TAY CHẮC CHẮN',
                    analysisText: `Tìm thấy ${occurrences.length} lần xuất hiện chính xác của hình cầu (${len} ván) này trong lịch sử.\nTất cả đều cho kết quả tiếp theo là: ${occurrences[0]}`,
                    confidence: 100,
                    isCertain: true
                };
            }
        }
        return null;
    }

    analyzeCurrentStreak(currentHistory) {
        if (currentHistory.length < 2) return { type: 'none', length: currentHistory.length };
        const last = currentHistory[currentHistory.length - 1];
        if (last === currentHistory[currentHistory.length - 2]) {
            let length = 0;
            for (let i = currentHistory.length - 1; i >= 0; i--) {
                if (currentHistory[i] === last) length++; else break;
            }
            return { type: 'bệt', length, value: last };
        } else {
            let length = 0;
            for (let i = currentHistory.length - 1; i >= 1; i--) {
                if (currentHistory[i] !== currentHistory[i-1]) length++; else break;
            }
            // Correct 1-1 length calculation: includes the last element
            return { type: '1-1', length: length + 1 };
        }
    }


    getPrediction(currentHistory, allHistoricalSessions, sessionSystemData) {
        const { optimalLength = null, lengthPerformance = {} } = sessionSystemData || {};

        if (currentHistory.length < this.MIN_HISTORY_FOR_ANALYSIS) {
            return { prediction: null, analysisText: `Cần ít nhất ${this.MIN_HISTORY_FOR_ANALYSIS} kết quả...`, confidence: 0, isCertain: false };
        }

        // 1. Try Optimal Length Prediction
        if (optimalLength && currentHistory.length >= optimalLength) {
            const pattern = currentHistory.slice(-optimalLength);
            const result = this.getPredictionForPattern(pattern, allHistoricalSessions);
            if (result.prediction) {
                const perf = lengthPerformance[optimalLength] || { wins: 0, total: 0 };
                // Ensure wins does not exceed total (data correction)
                if (perf.wins > perf.total) { perf.wins = perf.total;}
                const rate = perf.total > 0 ? (perf.wins / perf.total * 100).toFixed(1) : 'N/A';
                return {
                    prediction: result.prediction, recommendation: 'THEO DÀI TỐI ƯU', // Shorter name
                    analysisText: `Dùng chiều dài tối ưu: ${optimalLength} ván.\n(Tỷ lệ thắng: ${rate}% - ${perf.wins}/${perf.total})\n\nLịch sử:\n- P: ${result.votes.P.toFixed(1)} điểm\n- B: ${result.votes.B.toFixed(1)} điểm`,
                    confidence: result.confidence, isCertain: false
                };
            }
        }

        // 2. Try Certain Prediction
        const certainPrediction = this.findCertainPrediction(currentHistory, allHistoricalSessions);
        if (certainPrediction) return certainPrediction;

        // 3. Fallback to Longest Found Pattern
        let longestFoundPatternLen = -1;
        let predictionResult = null;

        for (let len = Math.min(this.MAX_PATTERN_LENGTH, currentHistory.length); len >= this.MIN_PATTERN_LENGTH; len--) {
            const pattern = currentHistory.slice(-len);
            const result = this.getPredictionForPattern(pattern, allHistoricalSessions);
             if (result.prediction) {
                 longestFoundPatternLen = len;
ci                  predictionResult = result;
                 break; // Found the longest, stop searching
             }
        }

        if (!predictionResult) {
            return { prediction: null, analysisText: 'Không tìm thấy hình cầu tương tự.', confidence: 0, isCertain: false };
        }


        // Generate recommendation based on streak and prediction
        const { prediction, confidence, votes } = predictionResult;
        const analysisTextPrefix = `Dùng hình cầu dài nhất (${longestFoundPatternLen} ván).\nLịch sử:\n- P: ${votes.P.toFixed(1)} điểm\n- B: ${votes.B.toFixed(1)} điểm`;

        const streakInfo = this.analyzeCurrentStreak(currentHistory);
        let recommendation = 'THEO LS'; // Default: Theo Lịch Sử

        if (streakInfo.type === 'bệt') {
            recommendation = prediction === streakInfo.value ? `THEO BỆT (${streakInfo.value}x${streakInfo.length})` : `BẺ BỆT (${streakInfo.value}x${streakInfo.length})`;
        } else if (streakInfo.type === '1-1') {
            const expectedNext = currentHistory[currentHistory.length-1] === 'P' ? 'B' : 'P';
            recommendation = prediction === expectedNext ? `THEO 1-1 (Dài ${streakInfo.length})` : `BẺ 1-1 (Dài ${streakInfo.length})`;
        }


        return {
            prediction: prediction,
            recommendation: recommendation,
            analysisText: `${analysisTextPrefix}\n\n🏆 Độ tin cậy: ${confidence.toFixed(1)}%`,
            confidence: confidence,
            isCertain: false
        };
    }
}


// --- GLOBAL STATE (Multi-System) ---
let state = {
    currentSessionId: null,
    sessions: {}, // { sessionId: { name, history, systemData: { sys1: {...}, sys2: {...}, sys3: {...} } } }
    matchers: { // Store matcher instances
        sys1: new PatternMatcher(10, 20),
        sys2: new PatternMatcher(10, 15),
        sys3: new PatternMatcher(10, 20)
    },
    // Store current round predictions for each system
    currentPredictions: { sys1: null, sys2: null, sys3: null }, // { prediction, confidence }
    originalSystemPredictions: { sys1: null, sys2: null, sys3: null }, // P/B before verdict
    currentFinalPredictions: { sys1: null, sys2: null, sys3: null }, // { verdict, prediction } after verdict
    currentChotPredictionsForLog: { sys1: null, sys2: null, sys3: null }, // Final Chot P/B to log { prediction, source, type, reason }
    // Shared data
    confidenceSequenceData: {} // Needs careful adaptation for multi-system use in Chot
};


// --- STATS CALCULATION (Mostly unchanged, used by individual systems) ---
function getPredictionStats(predictions) {
    const total = predictions.length;
    if (total === 0) return { rate: 0, correct: 0, total: 0 };
    const correct = predictions.filter(p => p.predicted === p.actual).length;
    return { rate: (correct / total) * 100, correct, total };
}

// Re-calculate confidence W/L sequences globally - Chot needs this
function updateGlobalConfidenceSequenceData() {
    const sequenceData = {};
    CONFIDENCE_RANGES.forEach(r => { sequenceData[r.key] = {}; });

    for (const sessionId in state.sessions) {
        const session = state.sessions[sessionId];
        // Use System 1's predictions for generating sequences, as Confidence/Verdict tables are hidden
        // Chot logic relies on these sequences based on HT1's confidence.
        const predictions = session.systemData?.sys1?.predictions || [];
        if (predictions.length === 0) continue;

        const sessionSequences = {};
        CONFIDENCE_RANGES.forEach(r => { sessionSequences[r.key] = []; });

        predictions.forEach(p => {
            const result = (p.predicted === p.actual) ? 'W' : 'L';
            const foundRange = CONFIDENCE_RANGES.find(r => p.confidence >= r.min && p.confidence < r.max);
            if (foundRange) {
                sessionSequences[foundRange.key].push(result);
            }
        });

        for (const key in sessionSequences) {
            if (sessionSequences[key].length > 0) {
                sequenceData[key][sessionId] = sessionSequences[key].join('');
            }
        }
    }
    state.confidenceSequenceData = sequenceData; // Update global state
}


// --- SELF-VERDICT LOGIC (Used by individual systems) ---
function getCurrentStreak(sequence) {
    if (!sequence || sequence.length === 0) return { type: null, length: 0 };
    const lastChar = sequence.slice(-1);
    let length = 0;
    for (let i = sequence.length - 1; i >= 0; i--) {
        if (sequence[i] === lastChar) length++; else break;
    }
    return { type: lastChar, length };
}

function calculateStreakStats(sequencesObject) {
    let maxW = 0, maxL = 0;
    const allSequences = Object.values(sequencesObject).join('');
    if (!allSequences) return { maxW: 0, maxL: 0 };
    const winStreaks = allSequences.match(/W+/g) || [];
    if (winStreaks.length > 0) maxW = Math.max(...winStreaks.map(s => s.length));
    const lossStreaks = allSequences.match(/L+/g) || [];
    if (lossStreaks.length > 0) maxL = Math.max(...lossStreaks.map(s => s.length));
    return { maxW, maxL };
}

// Calculates Verdict (Follow/Against/Neutral) based on System 1's confidence sequence data
function getFinalVerdict(systemKey) {
    const context = {
        prediction: state.currentPredictions[systemKey]?.prediction,
        confidence: state.currentPredictions[systemKey]?.confidence,
        sequenceData: state.confidenceSequenceData, // Uses globally calculated sequences (based on Sys1 confidence)
        currentSessionId: state.currentSessionId
    };

    if (!context.prediction) {
        return { verdict: 'neutral', explanation: 'Chưa có đủ dữ liệu.' };
    }

    const foundRange = CONFIDENCE_RANGES.find(r => context.confidence >= r.min && context.confidence < r.max);
    if (!foundRange) {
        return { verdict: 'neutral', explanation: 'Ngoài khoảng tin cậy.' };
    }

    const rangeKey = foundRange.key;
    const historicalSequences = { ...(context.sequenceData[rangeKey] || {}) }; // Handle potential undefined rangeKey
    const currentSequenceStr = historicalSequences[context.currentSessionId] || "";
    delete historicalSequences[context.currentSessionId]; // Exclude current session from historical analysis

    // Tier 1: Pattern Search (Longest first)
    const maxLen = Math.min(currentSequenceStr.length, 5);
    for (let len = maxLen; len >= 2; len--) {
        const patternToSearch = currentSequenceStr.slice(-len);
        let wins = 0, losses = 0;
        for (const sessionId in historicalSequences) {
            const history = historicalSequences[sessionId];
            let i = -1;
            while ((i = history.indexOf(patternToSearch, i + 1)) !== -1) {
                const nextCharIndex = i + patternToSearch.length;
                if (nextCharIndex < history.length) {
                    if (history[nextCharIndex] === 'W') wins++; else losses++;
                }
            }
        }
        if (wins + losses >= 2) { // Minimum occurrences for pattern
            const patternText = patternToSearch.replace(/W/g, 'Thắng-').replace(/L/g, 'Thua-').slice(0, -1);
            if (wins > losses) return { verdict: 'follow', explanation: `Quy luật ${len} ván (${patternText} -> Thắng)` };
            if (losses > wins) return { verdict: 'against', explanation: `Quy luật ${len} ván (${patternText} -> Thua)` };
            // If wins == losses, continue searching shorter patterns
        }
    }

    // Tier 2: Max Streak Analysis
    const currentStreak = getCurrentStreak(currentSequenceStr);
    const streakStats = calculateStreakStats(historicalSequences); // Calculate from other sessions
    if (currentStreak.type === 'W' && streakStats.maxW > 0 && currentStreak.length >= streakStats.maxW) {
        return { verdict: 'against', explanation: `Chuỗi Thắng (x${currentStreak.length}) >= Max LS (x${streakStats.maxW})` };
    }
    if (currentStreak.type === 'L' && streakStats.maxL > 0 && currentStreak.length >= streakStats.maxL) {
        return { verdict: 'follow', explanation: `Chuỗi Thua (x${currentStreak.length}) >= Max LS (x${streakStats.maxL})` };
    }

    // Tier 3: Cross-range Absolute Pattern (Check across all confidence ranges)
    const absolutePatternLength = Math.min(currentSequenceStr.length, 3);
    if (absolutePatternLength >= 2) {
        const patternToSearch = currentSequenceStr.slice(-absolutePatternLength);
        let crossWins = 0, crossLosses = 0;
        const MIN_ABSOLUTE_OCCURRENCES = 4;
        for (const rKey in context.sequenceData) { // Iterate through all ranges
            const otherRangeSequences = context.sequenceData[rKey];
            for (const sessionId in otherRangeSequences) {
                if (sessionId === context.currentSessionId) continue; // Skip current session
                const history = otherRangeSequences[sessionId];
                let i = -1;
                while ((i = history.indexOf(patternToSearch, i + 1)) !== -1) {
                    const nextCharIndex = i + patternToSearch.length;
                    if (nextCharIndex < history.length) {
                        if (history[nextCharIndex] === 'W') crossWins++; else crossLosses++;
                    }
                }
            }
        }
        const patternText = patternToSearch.replace(/W/g, 'Thắng-').replace(/L/g, 'Thua-').slice(0, -1);
        if (crossWins + crossLosses >= MIN_ABSOLUTE_OCCURRENCES) {
            if (crossWins === 0) return { verdict: 'against', explanation: `Quy luật tuyệt đối (${patternText} -> Thua)` };
            if (crossLosses === 0) return { verdict: 'follow', explanation: `Quy luật tuyệt đối (${patternText} -> Thắng)` };
        }
    }

    // Default verdict if no strong pattern or streak found
    return { verdict: 'neutral', explanation: 'Không tìm thấy quy luật rõ ràng.' };
}


// --- CHOT ANALYSIS LOGIC (Needs heavy adaptation) ---

// Gets W/L sequences for Chot analysis sources (Based on System 1's predictions/verdicts)
function getChotAnalysisData() {
    const sequencesBySource = CHOT_SOURCES.reduce((acc, key) => { acc[key] = {}; return acc; }, {});
    for (const sessionId in state.sessions) {
        const session = state.sessions[sessionId];
        const systemData = session.systemData?.sys1; // Base Chot on Sys1 results
        if (!systemData) continue;

        let followSeq = '', againstSeq = '';
        (systemData.verdictPredictions || []).forEach(p => {
            const result = p.predicted === p.actual ? 'W' : 'L';
            if (p.verdict === 'follow') followSeq += result;
            else if (p.verdict === 'against') againstSeq += result;
        });
        sequencesBySource.follow[sessionId] = followSeq;
        sequencesBySource.against[sessionId] = againstSeq;

        CONFIDENCE_RANGES.forEach(r => {
             if (!sequencesBySource[r.key]) sequencesBySource[r.key] = {};
             sequencesBySource[r.key][sessionId] = "";
        });

        (systemData.predictions || []).forEach(p => {
            const result = (p.predicted === p.actual) ? 'W' : 'L';
            const foundRange = CONFIDENCE_RANGES.find(r => p.confidence >= r.min && p.confidence < r.max);
            if (foundRange) {
                 sequencesBySource[foundRange.key][sessionId] += result;
            }
        });
    }
    return sequencesBySource;
}

// Find outcome after a specific W/L pattern (used by Chot)
function findNextOutcomeInHistory(pattern, historicalSequences) {
    if (!pattern || pattern.length < 1) return { W: 0, L: 0, total: 0 };
    let W = 0, L = 0;
    for (const sessionId in historicalSequences) {
        const history = historicalSequences[sessionId];
        if (!history || history.length < pattern.length + 1) continue;
        let i = -1;
        while ((i = history.indexOf(pattern, i + 1)) !== -1) {
            const nextCharIndex = i + pattern.length;
            // Check previous char to count only specific streak lengths
            const prevCharDifferent = (i === 0 || history[i - 1] !== pattern[pattern.length - 1]);
            if (prevCharDifferent && nextCharIndex < history.length) {
                if (history[nextCharIndex] === 'W') W++; else L++;
            }
        }
    }
    return { W, L, total: W + L };
}

// Find the best W/L pattern length for Chot prediction
function findBestChotPatternLength(currentSequence, historicalSequences, minLen = 3, maxLen = 20, minOccurrences = 2) {
    const possibleResults = [];
    for (let len = Math.min(maxLen, currentSequence.length); len >= minLen; len--) {
        const pattern = currentSequence.slice(-len);
        if (!pattern) continue;
        const stats = findNextOutcomeInHistory(pattern, historicalSequences);
        if (stats.total >= minOccurrences) {
            const rateW = stats.total > 0 ? stats.W / stats.total : 0;
            possibleResults.push({ length: len, stats: stats, rate: rateW });
        }
    }
    if (possibleResults.length === 0) return null;
    possibleResults.sort((a, b) => {
        const deviationA = Math.abs(a.rate - 0.5);
        const deviationB = Math.abs(b.rate - 0.5);
        if (deviationA !== deviationB) return deviationB - deviationA;
        return b.stats.total - a.stats.total;
    });
    return possibleResults[0];
}

// Analyze max W/L streak for Chot prediction
function analyzeMaxStreakChot(currentSequence, historicalSequences) { // Renamed slightly
    const { type: currentType, length: currentLength } = getCurrentStreak(currentSequence);
    if (!currentType) return null;
    const { maxW, maxL } = calculateStreakStats(historicalSequences);
    if (currentType === 'W' && maxW > 0 && currentLength >= maxW) {
        return {
            predictionType: 'MAX_STREAK', predictedWL: 'L',
            explanation: `Max W (${maxW})`, stats: { W: 0, L: 999, total: 999, maxW: maxW, maxL: maxL } // Include maxW/L in stats
        };
    }
    if (currentType === 'L' && maxL > 0 && currentLength >= maxL) {
        return {
            predictionType: 'MAX_STREAK', predictedWL: 'W',
            explanation: `Max L (${maxL})`, stats: { W: 999, L: 0, total: 999, maxW: maxW, maxL: maxL } // Include maxW/L in stats
        };
    }
    return null;
}

// Get the final Chot prediction (W/L) for a given source, combining Optimal, Max Streak, Fallback
function getChotPrediction(currentSequence, historicalSequences, sourceKey, sessionSystemData) {
    const MIN_PATTERN_LEN = 3;
    const MAX_PATTERN_LEN = 20;
    const MIN_PATTERN_OCCURRENCES = 2;

    const optimalLength = sessionSystemData?.chotOptimalLengths ? sessionSystemData.chotOptimalLengths[sourceKey] : null;

    // 1. Optimal Length
    if (optimalLength && currentSequence.length >= optimalLength) {
        const pattern = currentSequence.slice(-optimalLength);
        const stats = findNextOutcomeInHistory(pattern, historicalSequences);
        if (stats.total > 0) {
            if (stats.W > stats.L) return { predictionType: 'OPTIMAL', predictedWL: 'W', stats: stats, optimalLength: optimalLength };
            if (stats.L > stats.W) return { predictionType: 'OPTIMAL', predictedWL: 'L', stats: stats, optimalLength: optimalLength };
            // If balanced, continue to next tier
        }
    }

    // 2. Max Streak
    const maxStreakAnalysis = analyzeMaxStreakChot(currentSequence, historicalSequences);
    if (maxStreakAnalysis) return maxStreakAnalysis;

    // 3. Fallback Pattern
    if (currentSequence.length < MIN_PATTERN_LEN) return { predictionType: 'NOT_ENOUGH_WL' };
    const bestPatternInfo = findBestChotPatternLength(currentSequence, historicalSequences, MIN_PATTERN_LEN, MAX_PATTERN_LEN, MIN_PATTERN_OCCURRENCES);
    if (!bestPatternInfo) return { predictionType: 'NO_HISTORY_PATTERN' };
    const { stats, length } = bestPatternInfo;
    if (stats.W > stats.L) return { predictionType: 'FALLBACK', predictedWL: 'W', stats: stats, optimalLength: length };
    if (stats.L > stats.W) return { predictionType: 'FALLBACK', predictedWL: 'L', stats: stats, optimalLength: length };
    return { predictionType: 'BALANCED', stats: stats, optimalLength: length }; // W == L
}


// --- UI UPDATE FUNCTIONS ---

// Update shared Big Road
function updateBigRoadUI() {
    const history = state.sessions[state.currentSessionId]?.history || [];
    const roadDiv = document.getElementById('bigRoadDisplay');
    document.getElementById('totalGames').textContent = history.length;
    if (history.length === 0) {
        roadDiv.innerHTML = '<p class="text-gray-500 p-4">Chưa có kết quả...</p>';
        roadDiv.style.display = 'block'; // Ensure it's block for the paragraph
        return;
    }
    roadDiv.style.display = 'grid'; // Set back to grid if there's history
    roadDiv.innerHTML = ''; // Clear previous content

    const columns = [];
    if (history.length > 0) {
        let currentCol = [history[0]];
        for (let i = 1; i < history.length; i++) {
            if (history[i] === history[i-1]) {
                currentCol.push(history[i]);
            } else {
                columns.push(currentCol);
                currentCol = [history[i]];
            }
        }
        columns.push(currentCol); // Push the last column
    }

    columns.forEach(colData => {
        const colDiv = document.createElement('div');
        colDiv.className = 'road-col';
        colData.forEach(item => {
            const itemDiv = document.createElement('div');
            itemDiv.className = `road-item ${item === 'P' ? 'bg-blue-600' : 'bg-red-600'}`;
            itemDiv.textContent = item;
            colDiv.appendChild(itemDiv);
        });
        roadDiv.appendChild(colDiv);
    });

    // Scroll to the end
    roadDiv.scrollLeft = roadDiv.scrollWidth;
}

// Update accuracy for System 1 (as representative)
function updateAccuracyUI() {
    const predictions = state.sessions[state.currentSessionId]?.systemData?.sys1?.predictions || [];
    const stats = getPredictionStats(predictions);
    document.getElementById('accuracyRate').textContent = `${stats.rate.toFixed(1)}%`;
    document.getElementById('correctPredictions').textContent = stats.correct;
    document.getElementById('totalPredictions').textContent = stats.total;
}

// Update global accuracy for System 1
function updateGlobalAccuracyUI() {
    let allPredictionsSys1 = [];
     for(const sessionId in state.sessions) {
         const sys1Data = state.sessions[sessionId]?.systemData?.sys1;
         if(sys1Data?.predictions) {
             allPredictionsSys1.push(...sys1Data.predictions);
         }
     }
    const stats = getPredictionStats(allPredictionsSys1);
    document.getElementById('globalAccuracyRate').textContent = `${stats.rate.toFixed(1)}%`;
    document.getElementById('globalCorrectPredictions').textContent = stats.correct;
    document.getElementById('globalTotalPredictions').textContent = stats.total;
}

// Renders a single row in the Chot details table
function getChotRowHTML(name, currentSequence, analysisResult, isActive, finalPBprediction) {
    let wlPredictionText = '-';
    let wlPredictionColor = 'text-gray-500';
    let analysisTypeDisplay = '-';
    let predictedWL = analysisResult.predictedWL;

    if (analysisResult.predictionType === 'OPTIMAL') {
        analysisTypeDisplay = `Optimal ${analysisResult.optimalLength}`;
    } else if (analysisResult.predictionType === 'MAX_STREAK') {
        analysisTypeDisplay = analysisResult.explanation; // Show Max W/L explanation
        wlPredictionText = `-> ${predictedWL} (Max Streak)`; // Clarify source
        wlPredictionColor = predictedWL === 'W' ? 'text-green-400' : 'text-red-400';
    } else if (analysisResult.predictionType === 'FALLBACK') {
        analysisTypeDisplay = `Fallback ${analysisResult.optimalLength}`;
    } else if (analysisResult.predictionType === 'BALANCED') {
        analysisTypeDisplay = `FB ${analysisResult.optimalLength} (Cân)`;
         wlPredictionText = 'Cân bằng';
         wlPredictionColor = 'text-yellow-400';
    } else if (analysisResult.predictionType === 'NOT_ENOUGH_SAMPLES') {
        analysisTypeDisplay = `FB ${analysisResult.optimalLength} (Ít mẫu)`;
         wlPredictionText = 'Ít mẫu';
    } else if (analysisResult.predictionType === 'NO_HISTORY_PATTERN') {
        analysisTypeDisplay = 'Ko mẫu LS';
         wlPredictionText = 'Ko mẫu LS';
    } else if (analysisResult.predictionType === 'NOT_ENOUGH_WL') {
        analysisTypeDisplay = 'Chờ W/L';
         wlPredictionText = 'Chờ W/L';
    }

    // Update text/color for Optimal and Fallback based on W/L prediction
    if ((analysisResult.predictionType === 'OPTIMAL' || analysisResult.predictionType === 'FALLBACK') && predictedWL) {
        const { stats } = analysisResult;
        const rate = stats.total > 0 ? (predictedWL === 'W' ? stats.W / stats.total : stats.L / stats.total) * 100 : 0;
        wlPredictionText = `-> ${predictedWL} (${rate.toFixed(0)}%)`;
        wlPredictionColor = predictedWL === 'W' ? 'text-green-400' : 'text-red-400';
    }


    let pbIndicator = '';
    if (isActive && finalPBprediction) {
        const pbColor = finalPBprediction === 'P' ? 'text-blue-400' : 'text-red-400';
        pbIndicator = `<span class="font-bold ${pbColor} ml-1">[${finalPBprediction}]</span>`;
    }

    const activeClass = isActive ? 'bg-gray-700 bg-opacity-60 ring-1 ring-purple-500' : 'bg-gray-900';

    // W/L History Bars
    const displayedHistory = currentSequence.slice(-30); // Max 30 bars
    let individualBarsHTML = `<div class="flex items-end justify-center gap-px h-5 my-auto overflow-hidden" title="Diễn biến W/L gần đây (Tối đa 30)">`;
    if (displayedHistory.length > 0) {
        for (const result of displayedHistory) {
            const isWin = result === 'W';
            const barClass = isWin ? 'bg-green-500 h-5' : 'bg-red-500 h-2'; // Win = tall green, Loss = short red
            const title = `Kết quả: ${isWin ? 'THẮNG' : 'THUA'}`;
            individualBarsHTML += `<div class="flex-shrink-0 w-1 ${barClass} rounded-t-sm" title="${title}"></div>`;
        }
    } else {
        individualBarsHTML += `<div class="w-full text-center"><span class="text-gray-600 text-xs">Chưa có</span></div>`;
t   }
    individualBarsHTML += '</div>';

    // Grid layout for the row
    return `
    <div class="grid grid-cols-12 gap-2 items-center text-xs mb-1 p-1.5 ${activeClass} rounded-lg transition-colors duration-300">
        <div class="col-span-2 font-semibold ${isActive ? 'text-purple-300' : 'text-gray-300'} truncate" title="${name}">${name}</div>
        <div class="col-span-3 text-center text-gray-400 truncate" title="Loại phân tích">${analysisTypeDisplay}</div>
        <div class="col-span-3">
            ${individualBarsHTML}
        </div>
        <div class="col-span-4 text-right font-bold ${wlPredictionColor} truncate" title="${wlPredictionText}">
            ${wlPredictionText}
            ${pbIndicator}
        </div>
    </div>
    `;
}

// Updates ONE Chot Analysis Panel based on systemKey
function updateChotAnalysisUI(systemKey) {
    const MAX_BARS_TO_SHOW = 50;
    // Get specific elements for this system
    const finalChotResultDiv = document.getElementById(`finalChotResult${systemKey.slice(-1)}`);
    const finalChotResultText = document.getElementById(`finalChotResultText${systemKey.slice(-1)}`);
    const chotAnalysisDetailsDiv = document.getElementById(`chotAnalysisDetails${systemKey.slice(-1)}`);
    const chotHistoryChartDiv = document.getElementById(`chotHistoryChart${systemKey.slice(-1)}`);
    const chotAccuracyStatsSpan = document.getElementById(`chotAccuracyStats${systemKey.slice(-1)}`);

    if (!finalChotResultDiv || !finalChotResultText || !chotAnalysisDetailsDiv || !chotHistoryChartDiv || !chotAccuracyStatsSpan) {
        console.error(`UI elements missing for Chot system: ${systemKey}`);
        return;
    }

    const activeSourcesKeys = new Set();
    const originalSystemPB = state.originalSystemPredictions[systemKey]; // Use this system's original P/B
    const currentConfidence = state.currentPredictions[systemKey]?.confidence; // Use this system's confidence
    const finalVerdictInfo = state.currentFinalPredictions[systemKey]; // Use this system's verdict
    state.currentChotPredictionsForLog[systemKey] = null; // Reset log prediction for this system

    let analysisRowsHTML = '';
    const finalVotesPB = { P: 0, B: 0 };
    const allSequences = getChotAnalysisData(); // Get global W/L sequences (based on Sys1)
    const currentSessionId = state.currentSessionId;
    const session = currentSessionId ? state.sessions[currentSessionId] : null;
    const sessionSystemData = session?.systemData?.[systemKey]; // Get specific system data for optimal lengths

    if (originalSystemPB && finalVerdictInfo !== null && currentSessionId && sessionSystemData) {
        // Determine active Chot sources based on this system's verdict and confidence
        if (finalVerdictInfo.verdict === 'follow') activeSourcesKeys.add('follow');
        else if (finalVerdictInfo.verdict === 'against') activeSourcesKeys.add('against');
        const activeConfidenceRange = CONFIDENCE_RANGES.find(r => currentConfidence >= r.min && currentConfidence < r.max);
        if (activeConfidenceRange) activeSourcesKeys.add(activeConfidenceRange.key);

        const sources = CHOT_SOURCES.map(key => ({
            key: key,
            name: key === 'follow' ? 'Theo HT' : key === 'against' ? 'Ngược HT' : `${key.replace('-', ' - ')}%`
        }));

        for (const source of sources) {
            const isActive = activeSourcesKeys.has(source.key);
            const currentSequence = allSequences[source.key]?.[currentSessionId] || "";
            const historicalData = { ...allSequences[source.key] };
            if(historicalData) delete historicalData[currentSessionId]; // Exclude current session history

            // Get Chot prediction using this system's optimal lengths
            const analysisResult = getChotPrediction(currentSequence, historicalData, source.key, sessionSystemData);

            let finalPBprediction = null;
            let voteFor = null;
            if (isActive && analysisResult.predictedWL) {
                const predictedWL = analysisResult.predictedWL;
                 // Logic to determine P/B vote based on W/L prediction and source type
                 if (source.key === 'against') {
                    // If source is "Against System"
                    voteFor = (predictedWL === 'W')
                        ? (originalSystemPB === 'P' ? 'B' : 'P') // W means "Against" was correct -> vote opposite of original
                        : originalSystemPB;                      // L means "Against" was wrong -> vote for original
                } else {
                    // If source is "Follow System" or a confidence range
                    voteFor = (predictedWL === 'W')
                        ? originalSystemPB                      // W means "Follow" was correct -> vote for original
                        : (originalSystemPB === 'P' ? 'B' : 'P'); // L means "Follow" was wrong -> vote opposite of original
                }
                finalVotesPB[voteFor]++;
                finalPBprediction = voteFor;
            }
            analysisRowsHTML += getChotRowHTML(source.name, currentSequence, analysisResult, isActive, finalPBprediction);
        }
        chotAnalysisDetailsDiv.innerHTML = analysisRowsHTML || '<p class="text-gray-500 text-center py-2">Chưa đủ W/L...</p>';
    } else {
        state.currentChotPredictionsForLog[systemKey] = null;
        chotAnalysisDetailsDiv.innerHTML = `<p class="text-gray-500 text-center py-2">Chờ ${systemKey.toUpperCase()} tính toán...</p>`;
    }

    // Determine and display final Chot vote result for this system
    let finalChotPredictionTextContent = '... Chờ tín hiệu ...';
    let finalChotPredictionColor = 'text-gray-400';
    let finalChotBorderColor = 'border-purple-500'; // Default for system 1
    if (systemKey === 'sys2') finalChotBorderColor = 'border-teal-500';
    if (systemKey === 'sys3') finalChotBorderColor = 'border-rose-500';
    let finalChotPB = null;
    const totalVotes = finalVotesPB.P + finalVotesPB.B;

    if (totalVotes > 0) {
        if (finalVotesPB.P > finalVotesPB.B) {
            finalChotPB = 'P';
            finalChotPredictionTextContent = `PLAYER (${finalVotesPB.P}/${totalVotes} phiếu)`;
            finalChotPredictionColor = 'text-blue-400';
            finalChotBorderColor = 'border-blue-500';
        } else if (finalVotesPB.B > finalVotesPB.P) {
            finalChotPB = 'B';
            finalChotPredictionTextContent = `BANKER (${finalVotesPB.B}/${totalVotes} phiếu)`;
            finalChotPredictionColor = 'text-red-400';
            finalChotBorderColor = 'border-red-500';
        } else {
            finalChotPredictionTextContent = `HÒA (${finalVotesPB.P}-${finalVotesPB.B})`;
            finalChotPredictionColor = 'text-yellow-400';
            finalChotBorderColor = 'border-yellow-500';
        }
    } else if (originalSystemPB && finalVerdictInfo !== null) {
        finalChotPredictionTextContent = 'Ko đủ phiếu';
    }

    // Store the final Chot P/B prediction for logging when result is added
    state.currentChotPredictionsForLog[systemKey] = {
        prediction: finalChotPB,
        source: 'CHOT_VOTE' // Indicate it came from the voting mechanism
    };

    // Update the UI elements for this system's Chot panel
    finalChotResultDiv.className = `text-center bg-gray-900 py-3 rounded-lg border-2 ${finalChotBorderColor} mb-4 transition-all duration-300`;
    finalChotResultText.textContent = finalChotPredictionTextContent;
    finalChotResultText.className = `text-xl font-extrabold ${finalChotPredictionColor}`;

    // Update Chot history chart for this system
    const chotHistory = sessionSystemData?.chotPredictions || [];
    let correctChot = 0;
    const totalChot = chotHistory.filter(p => p.predicted !== null).length; // Only count non-null predictions
    let barsHTML = '';
    const historyToShow = chotHistory.slice(-MAX_BARS_TO_SHOW);

    if (historyToShow.length > 0) {
        historyToShow.forEach(p => {
             if (p && p.predicted !== undefined && p.actual !== undefined && p.predicted !== null) { // Check prediction is not null
                const isCorrect = p.predicted === p.actual;
                if (isCorrect) correctChot++;
                const barClass = isCorrect ? 'history-bar-correct' : 'history-bar-incorrect';
                const title = `Chốt ${systemKey.slice(-1)}: ${p.predicted}, Ra: ${p.actual} -> ${isCorrect ? 'Đúng' : 'Sai'}`;
                barsHTML += `<div class="history-bar ${barClass}" title="${title}"></div>`;
            }
        });
        chotHistoryChartDiv.innerHTML = barsHTML;
    } else {
        chotHistoryChartDiv.innerHTML = `<p class="text-gray-600 text-xs text-center w-full">Chưa có LS Chốt ${systemKey.toUpperCase()}...</p>`;
    }
    const accuracyRate = totalChot > 0 ? (correctChot / totalChot * 100).toFixed(1) : '0.0';
    chotAccuracyStatsSpan.textContent = `Đ: ${correctChot}/${totalChot} (${accuracyRate}%)`;
}


// --- Master UI Update ---
function updateAllUI() {
    if (!state.currentSessionId) return; // Don't update if no session selected

    updateBigRoadUI(); // Update shared road

    // Recalculate global W/L sequences (based on Sys1 confidence) needed by Verdict/Chot
    updateGlobalConfidenceSequenceData();

    // Update calculations and UI for each system
    for (const systemKey in state.matchers) {
         // 1. Calculate Core Prediction (P/B, Confidence) using the system's matcher
         const session = state.sessions[state.currentSessionId];
         const sessionSystemData = session?.systemData?.[systemKey];
         const { prediction, recommendation, analysisText, confidence, isCertain } = state.matchers[systemKey].getPrediction(
             session.history || [],
             state.sessions, // Pass all sessions for historical lookup
             sessionSystemData // Pass system-specific performance data
         );
         state.currentPredictions[systemKey] = { prediction, confidence };
         state.originalSystemPredictions[systemKey] = prediction;

         // 2. Calculate Final Verdict (Follow/Against/Neutral) for this system
         const finalVerdict = getFinalVerdict(systemKey);
         let finalPredictionForDisplay = prediction;
         if (finalVerdict.verdict === 'against' && !isCertain) {
            finalPredictionForDisplay = prediction === 'P' ? 'B' : 'P';
         }
         state.currentFinalPredictions[systemKey] = { verdict: finalVerdict.verdict, prediction: finalPredictionForDisplay };

         // 3. Update the Chot Analysis UI panel specifically for this system
         updateChotAnalysisUI(systemKey);
    }


    // Update shared simple accuracy stats (using System 1 as representative)
    updateAccuracyUI();
    updateGlobalAccuracyUI();

    // Session selector update (reflects history length change)
    updateSessionSelector();
}

// Toggle Session Management Section visibility
function toggleSessionManagement() {
    const content = document.getElementById('sessionManagementContent');
    const icon = document.getElementById('toggleSessionIcon');
    if (content.style.maxHeight && content.style.maxHeight !== '0px') {
        content.style.maxHeight = '0px';
        icon.style.transform = 'rotate(-180deg)';
    } else {
        // Expand to fit content
        content.style.maxHeight = content.scrollHeight + "px";
        icon.style.transform = 'rotate(0deg)';
    }
}


// --- Chot Performance Update (Apply consistency) ---
// This function updates the optimal length tracking for Chot sources for a specific system
function updateChotLengthPerformance(session, systemKey, tier1Prediction, actualResult) {
    if (!session || !session.systemData || !session.systemData[systemKey]) return;
    
    // Only update if we have an actual result and a prediction to compare
    if (!tier1Prediction || !actualResult) {
        // This case might be hit during undo, let's just recalculate optimal based on existing stats
         const systemData = session.systemData[systemKey];
         if (!systemData.chotLengthPerformance) systemData.chotLengthPerformance = CHOT_SOURCES.reduce((acc, key) => { acc[key] = {}; return acc; }, {});
         if (!systemData.chotOptimalLengths) systemData.chotOptimalLengths = CHOT_SOURCES.reduce((acc, key) => { acc[key] = null; return acc; }, {});
         
         const newChotOptimalLengths = { ...systemData.chotOptimalLengths };
         for (const sourceKey of CHOT_SOURCES) {
             const perfData = systemData.chotLengthPerformance[sourceKey];
             const candidates = [];
             for (let len = 3; len <= 20; len++) {
                 if (perfData[len] && perfData[len].total > 0) {
                     candidates.push({
                         length: len,
                         rate: perfData[len].wins / perfData[len].total,
                         total: perfData[len].total
                     });
                  }
             }
             if (candidates.length > 0) {
                  candidates.sort((a, b) => b.rate !== a.rate ? b.rate - a.rate : b.total - a.total);
                  newChotOptimalLengths[sourceKey] = candidates[0].length;
             } else {
                  newChotOptimalLengths[sourceKey] = null;
             }
         }
         systemData.chotOptimalLengths = newChotOptimalLengths;
         return; // Exit as we were just recalculating
    }


    const actualWL = (tier1Prediction === actualResult) ? 'W' : 'L';
    const allSequences = getChotAnalysisData(); // Get global sequences
    const systemData = session.systemData[systemKey];

    // Initialize performance objects if they don't exist
    if (!systemData.chotLengthPerformance) systemData.chotLengthPerformance = CHOT_SOURCES.reduce((acc, key) => { acc[key] = {}; return acc; }, {});
    if (!systemData.chotOptimalLengths) systemData.chotOptimalLengths = CHOT_SOURCES.reduce((acc, key) => { acc[key] = null; return acc; }, {});

    const newChotOptimalLengths = { ...systemData.chotOptimalLengths }; // Work on a copy

    for (const sourceKey of CHOT_SOURCES) {
        const perfData = systemData.chotLengthPerformance[sourceKey];
        const historicalSequences = { ...allSequences[sourceKey] }; // Copy historical data for this source
        if(historicalSequences) delete historicalSequences[state.currentSessionId]; // Exclude current session
        const fullCurrentSequence = allSequences[sourceKey]?.[state.currentSessionId] || ""; // Get full sequence for current session
        const prevSequence = fullCurrentSequence.slice(0, -1); // Sequence *before* the latest result was added

        const candidates = []; // To store potential optimal lengths

        // Evaluate performance for lengths 3 to 20
        for (let len = 3; len <= 20; len++) {
            if (prevSequence.length < len) continue; // Not enough history for this length

            const pattern = prevSequence.slice(-len);
            const stats = findNextOutcomeInHistory(pattern, historicalSequences); // Find historical outcomes

            if (stats.total > 0 && stats.W !== stats.L) { // Only update if there's a clear historical bias
                const predictedWL = (stats.W > stats.L) ? 'W' : 'L'; // Historical prediction for this pattern

                // Update performance tracking for this length
                if (!perfData[len]) perfData[len] = { wins: 0, total: 0 };
                perfData[len].total++; // Increment total times this length predicted
                if (predictedWL === actualWL) perfData[len].wins++; // Increment wins if prediction matched actual outcome
            }

             // Consider this length as a candidate if it has been tracked
             if (perfData[len] && perfData[len].total > 0) {
                 candidates.push({
                     length: len,
                     rate: perfData[len].wins / perfData[len].total,
                     total: perfData[len].total
                 });
             }
        }

        // Determine the new optimal length for this source based on performance
        if (candidates.length > 0) {
            // Sort by win rate (descending), then by total predictions (descending)
            candidates.sort((a, b) => b.rate !== a.rate ? b.rate - a.rate : b.total - a.total);
            newChotOptimalLengths[sourceKey] = candidates[0].length; // Best performing length
        } else {
            newChotOptimalLengths[sourceKey] = null; // No suitable length found
        }
    }
    systemData.chotOptimalLengths = newChotOptimalLengths; // Update the session data
}


// --- EVENT HANDLERS & ACTIONS ---

// Add a new result (P or B)
function addResult(result) {
    if (!state.currentSessionId) {
        showToast("Vui lòng tạo hoặc chọn một phiên.", "warning");
        return;
    }
    const session = state.sessions[state.currentSessionId];
    if (!session) return; // Should not happen

     // Ensure systemData structure exists
     if (!session.systemData) {
        session.systemData = { sys1: {}, sys2: {}, sys3: {} };
    }

    // Capture predictions *before* adding the result
    const predictionsToLog = { ...state.currentPredictions };
    const finalPredictionsToLog = { ...state.currentFinalPredictions };
    const chotPredictionsToLog = { ...state.currentChotPredictionsForLog };
    const originalPredictionsToLog = { ...state.originalSystemPredictions };

    // --- Update Shared History ---
    session.history.push(result);

    // --- Update Data for EACH System ---
    for (const systemKey in state.matchers) {
        // Ensure structure exists for this system within the session
        if (!session.systemData[systemKey]) {
            session.systemData[systemKey] = {
                predictions: [], verdictPredictions: [], chotPredictions: [],
                lengthPerformance: {}, optimalLength: null,
                chotLengthPerformance: CHOT_SOURCES.reduce((acc, key) => { acc[key] = {}; return acc; }, {}),
                chotOptimalLengths: CHOT_SOURCES.reduce((acc, key) => { acc[key] = null; return acc; }, {}),
            };
        }
        const systemData = session.systemData[systemKey];

        // Log Core Prediction
        const corePred = predictionsToLog[systemKey];
        if (corePred && corePred.prediction) {
             if (!systemData.predictions) systemData.predictions = [];
            systemData.predictions.push({ predicted: corePred.prediction, actual: result, confidence: corePred.confidence });
        }

        // Log Final Verdict Prediction
        const finalPred = finalPredictionsToLog[systemKey];
        if (finalPred && finalPred.prediction) {
             if (!systemData.verdictPredictions) systemData.verdictPredictions = [];
            systemData.verdictPredictions.push({
                verdict: finalPred.verdict,
                predicted: finalPred.prediction,
                actual: result
            });
        }

        // Log Chot Prediction
        const chotPred = chotPredictionsToLog[systemKey];
         if (!systemData.chotPredictions) systemData.chotPredictions = [];
        // Only log if Chot made a P/B prediction
        if (chotPred && chotPred.prediction) {
            systemData.chotPredictions.push({
                predicted: chotPred.prediction,
                actual: result,
                // Include source/type/reason if available from chotPred object
                source: chotPred.source || 'Unknown',
                type: chotPred.type || 'Unknown',
                reason: chotPred.reason || 'Unknown'
            });
        } else {
             // Optionally log a 'null' prediction entry if needed for strict sequence tracking
              systemData.chotPredictions.push({ predicted: null, actual: result, source: 'None', type: 'None', reason: 'No Chot prediction'});
        }


        // Update Core Optimal Length Performance
        const newOptimalLength = updateLengthPerformanceAndFindOptimal(
            systemData, // Pass the specific system's data object
            systemKey, // <<< FIX: Pass the systemKey
            session.history.slice(0, -1), // History *before* adding current result
            state.sessions, // Pass all sessions for historical context
            result // The actual result
        );
        systemData.optimalLength = newOptimalLength;


        // Update Chot Optimal Length Performance
        updateChotLengthPerformance(
             session,
             systemKey,
             originalPredictionsToLog[systemKey], // Use the system's ORIGINAL P/B prediction for WL check
             result
         );
    }


  _   // --- Reset global state for the next round ---
    state.currentPredictions = { sys1: null, sys2: null, sys3: null };
    state.originalSystemPredictions = { sys1: null, sys2: null, sys3: null };
    state.currentFinalPredictions = { sys1: null, sys2: null, sys3: null };
g   state.currentChotPredictionsForLog = { sys1: null, sys2: null, sys3: null };

    // --- Save and Update UI ---
    saveSessions();
    updateAllUI(); // Recalculates predictions for the *next* round
}

// Refactored to update performance for a specific system
// <<< FIX: Added systemKey parameter
function updateLengthPerformanceAndFindOptimal(systemData, systemKey, history, allSessions, newResult) {
    if (!systemData) return null;
    if (!systemData.lengthPerformance) systemData.lengthPerformance = {};

    const candidates = [];
    // Use the specific matcher instance for this system
    const matcher = state.matchers[systemKey]; // <<< FIX: Use systemKey to get matcher
    if (!matcher) return systemData.optimalLength; // Should not happen

    const minLen = matcher.MIN_PATTERN_LENGTH;
    const maxLen = matcher.MAX_PATTERN_LENGTH;


    for (let len = minLen; len <= maxLen; len++) {
        if (history.length < len) continue;
        const pattern = history.slice(-len);
        // Get prediction based on history *before* the new result
        const { prediction } = matcher.getPredictionForPattern(pattern, allSessions);

        if (prediction) {
             // Initialize performance for this length if needed
            if (!systemData.lengthPerformance[len]) systemData.lengthPerformance[len] = { wins: 0, total: 0 };
            const stats = systemData.lengthPerformance[len];
            stats.total++; // Increment count for this length
            if (prediction === newResult) stats.wins++; // Increment wins if correct

             // Consider as candidate if performance is tracked
            if (stats.total > 0) {
                 candidates.push({ length: len, rate: stats.wins / stats.total, total: stats.total });
             }
        }
    }

    if (candidates.length === 0) {
        return systemData.optimalLength; // Keep old optimal length if no candidates found
    }

    // Sort candidates: highest win rate first, then highest total predictions
    candidates.sort((a, b) => b.rate !== a.rate ? b.rate - a.rate : b.total - a.total);
    return candidates[0].length; // Return the best performing length
}


// Undo the last added result
function undoLast() {
    if (!state.currentSessionId || !state.sessions[state.currentSessionId]?.history?.length) {
        showToast("Không có gì để hoàn tác.", "warning");
        return;
    }

    const session = state.sessions[state.currentSessionId];
    const lastResult = session.history.pop(); // Remove last result from shared history

    // --- Undo for EACH System ---
    for (const systemKey in state.matchers) {
        const systemData = session.systemData?.[systemKey];
        if (!systemData) continue; // Skip if system data doesn't exist for this session

        // Pop last prediction log entries
        if (systemData.predictions?.length > 0) systemData.predictions.pop();
        if (systemData.verdictPredictions?.length > 0) systemData.verdictPredictions.pop();
        if (systemData.chotPredictions?.length > 0) systemData.chotPredictions.pop();

        // --- Recalculate Performance Metrics ---
        // This is complex to perfectly reverse. A simpler approach is to recalculate
        // the optimal lengths based on the now-shortened history.
        // We need the history *before* the undone result was added.
        const historyForRecalc = session.history; // Already popped

         // Recalculate Core Optimal Length Performance (Needs careful recalculation/reversal)
         // For simplicity in undo, we might just recalculate optimal length without reversing individual performance stats perfectly.
         const tempCandidatesCore = [];
         if (systemData.lengthPerformance) {
              const matcher = state.matchers[systemKey];
              const minLen = matcher.MIN_PATTERN_LENGTH;
              const maxLen = matcher.MAX_PATTERN_LENGTH;
              // Reverse the last performance update (approximate)
              // This part is tricky and error-prone. Recalculating might be better.
              // Let's stick to recalculating the optimal length based on current perf stats
              for (const lenStr in systemData.lengthPerformance) {
                  const len = parseInt(lenStr, 10);
                   const stats = systemData.lengthPerformance[len];
                   // Simple Reversal Attempt (Might be slightly inaccurate if multiple predictions happened)
                  // Find the prediction that *would have been made* before the last result
                  if(historyForRecalc.length >= len){
                       const pattern = historyForRecalc.slice(-len);
                       const { prediction } = matcher.getPredictionForPattern(pattern, state.sessions); // Needs context of other sessions too
                       if(prediction){
                           // This logic assumes the last entry WAS for this length - flawed.
s                           // stats.total = Math.max(0, stats.total - 1);
                           // if(prediction === lastResult) stats.wins = Math.max(0, stats.wins - 1);
                       }
                  }

                   if (stats.total > 0) {
                       tempCandidatesCore.push({ length: len, rate: stats.wins / stats.total, total: stats.total });
                   }
              }
              if (tempCandidatesCore.length > 0) {
                  tempCandidatesCore.sort((a, b) => b.rate !== a.rate ? b.rate - a.rate : b.total - a.total);
                  systemData.optimalLength = tempCandidatesCore[0].length;
              } else {
                  systemData.optimalLength = null;
              }
         }


         // Recalculate Chot Optimal Lengths (similar complexity)
         // Again, recalculating the optimal based on current stats is simpler than perfect reversal.
         updateChotLengthPerformance(session, systemKey, null, null); // Call with nulls to trigger recalculation based on current state


    } // End loop through systems


    // --- Reset current predictions and Save ---
    state.currentPredictions = { sys1: null, sys2: null, sys3: null };
    state.originalSystemPredictions = { sys1: null, sys2: null, sys3: null };
    state.currentFinalPredictions = { sys1: null, sys2: null, sys3: null };
    state.currentChotPredictionsForLog = { sys1: null, sys2: null, sys3: null };

    saveSessions();
    updateAllUI(); // Recalculate predictions based on the state after undo
}


// Clear history and stats for the current session
function clearCurrentSessionHistory() {
    if (!state.currentSessionId) return;
    const session = state.sessions[state.currentSessionId];
    session.history = []; // Clear shared history
    // Clear data for all systems within this session
    session.systemData = {
        sys1: { predictions: [], verdictPredictions: [], chotPredictions: [], lengthPerformance: {}, optimalLength: null, chotLengthPerformance: CHOT_SOURCES.reduce((acc, key) => { acc[key] = {}; return acc; }, {}), chotOptimalLengths: CHOT_SOURCES.reduce((acc, key) => { acc[key] = null; return acc; }, {}) },
        sys2: { predictions: [], verdictPredictions: [], chotPredictions: [], lengthPerformance: {}, optimalLength: null, chotLengthPerformance: CHOT_SOURCES.reduce((acc, key) => { acc[key] = {}; return acc; }, {}), chotOptimalLengths: CHOT_SOURCES.reduce((acc, key) => { acc[key] = null; return acc; }, {}) },
        sys3: { predictions: [], verdictPredictions: [], chotPredictions: [], lengthPerformance: {}, optimalLength: null, chotLengthPerformance: CHOT_SOURCES.reduce((acc, key) => { acc[key] = {}; return acc; }, {}), chotOptimalLengths: CHOT_SOURCES.reduce((acc, key) => { acc[key] = null; return acc; }, {}) }
    };
    saveSessions();
    updateAllUI(); // Update UI to reflect cleared state
}


// --- SESSION MANAGEMENT ---
function getSessions() {
    try {
        const stored = localStorage.getItem('baccaratCongPhuc_v1'); // Use new storage key
        const parsed = JSON.parse(stored);
        // Basic validation
        if (parsed && typeof parsed === 'object') {
            // Ensure systemData structure exists in loaded sessions
            Object.values(parsed).forEach(s => {
                if (!s.systemData) {
                     s.systemData = { sys1: {}, sys2: {}, sys3: {} };
                }
                 for(const key of ['sys1', 'sys2', 'sys3']) {
                    if(!s.systemData[key]) s.systemData[key] = {};
                     // Ensure basic arrays and properties exist
                     if (!s.systemData[key].predictions) s.systemData[key].predictions = [];
                     if (!s.systemData[key].verdictPredictions) s.systemData[key].verdictPredictions = [];
                     if (!s.systemData[key].chotPredictions) s.systemData[key].chotPredictions = [];
                     if (!s.systemData[key].lengthPerformance) s.systemData[key].lengthPerformance = {};
                     if (s.systemData[key].optimalLength === undefined) s.systemData[key].optimalLength = null;
                     if (!s.systemData[key].chotLengthPerformance) s.systemData[key].chotLengthPerformance = CHOT_SOURCES.reduce((acc, k) => { acc[k] = {}; return acc; }, {});
                      if (!s.systemData[key].chotOptimalLengths) s.systemData[key].chotOptimalLengths = CHOT_SOURCES.reduce((acc, k) => { acc[k] = null; return acc; }, {});
G                }
            });
            return parsed;
        }
        return {};
    } catch (e) {
        console.error("Error loading sessions:", e);
        return {};
    }
}
function saveSessions() {
    try {
        localStorage.setItem('baccaratCongPhuc_v1', JSON.stringify(state.sessions));
        localStorage.setItem('lastActiveCongPhuc_v1', state.currentSessionId);
    } catch (e) {
        console.error("Error saving sessions:", e);
        showToast("Lỗi lưu trữ dữ liệu phiên!", "error");
    }
}
function renameSession() {
    if (!state.currentSessionId) return;
    const currentName = state.sessions[state.currentSessionId].name;
    showCustomPrompt("Nhập tên mới cho phiên:", currentName, (newName) => {
        if (newName && newName.trim() !== "") {
            state.sessions[state.currentSessionId].name = newName.trim();
            saveSessions();
            updateSessionSelector(); // Update display
        }
    });
}
function updateSessionSelector() {
    const selector = document.getElementById('sessionSelector');
    selector.innerHTML = ''; // Clear existing options
    const sortedKeys = Object.keys(state.sessions).sort((a, b) => {
        // Sort by timestamp in ID, descending (newest first)
        const timeA = parseInt(a.split('-')[1] || 0);
        const timeB = parseInt(b.split('-')[1] || 0);
        return timeB - timeA; // Newest first
    });

    sortedKeys.forEach(sessionId => {
        const session = state.sessions[sessionId];
        const option = document.createElement('option');
        option.value = sessionId;
        option.textContent = `${session.name} (${session.history?.length || 0} ván)`; // Handle missing history
        if (sessionId === state.currentSessionId) {
            option.selected = true;
        }
        selector.appendChild(option);
    });

    // Update event listener for selection change
     selector.onchange = () => { // Use onchange for better multi-select compatibility if needed later
         if (selector.selectedOptions.length === 1) {
             const selectedId = selector.value;
             if (selectedId !== state.currentSessionId) {
                 loadSession(selectedId);
             }
         }
     };
}

function createNewSession() {
    const newId = `session-${Date.now()}`;
    state.currentSessionId = newId;
    state.sessions[newId] = {
        name: `Phiên ${new Date().toLocaleString('vi-VN')}`,
        history: [],
        // Initialize systemData structure for the new session
        systemData: {
            sys1: { predictions: [], verdictPredictions: [], chotPredictions: [], lengthPerformance: {}, optimalLength: null, chotLengthPerformance: CHOT_SOURCES.reduce((acc, key) => { acc[key] = {}; return acc; }, {}), chotOptimalLengths: CHOT_SOURCES.reduce((acc, key) => { acc[key] = null; return acc; }, {}) },
            sys2: { predictions: [], verdictPredictions: [], chotPredictions: [], lengthPerformance: {}, optimalLength: null, chotLengthPerformance: CHOT_SOURCES.reduce((acc, key) => { acc[key] = {}; return acc; }, {}), chotOptimalLengths: CHOT_SOURCES.reduce((acc, key) => { acc[key] = null; return acc; }, {}) },
            sys3: { predictions: [], verdictPredictions: [], chotPredictions: [], lengthPerformance: {}, optimalLength: null, chotLengthPerformance: CHOT_SOURCES.reduce((acc, key) => { acc[key] = {}; return acc; }, {}), chotOptimalLengths: CHOT_SOURCES.reduce((acc, key) => { acc[key] = null; return acc; }, {}) }
        }
    };
    saveSessions();
    updateSessionSelector();
    updateAllUI(); // Update UI for the new empty session
}
function deleteSelectedSessions() {
    const selector = document.getElementById('sessionSelector');
    const selectedIds = Array.from(selector.selectedOptions).map(opt => opt.value);

    if (selectedIds.length === 0) {
        showToast('Vui lòng chọn ít nhất một phiên để xóa.', 'warning');
        return;
    }
    // Prevent deleting the *only* session
    if (Object.keys(state.sessions).length === 1 && selectedIds.length === 1) {
         showToast('Không thể xóa phiên cuối cùng. Tạo phiên mới trước.', 'error');
         return;
    }
     // Allow deleting all if multiple selected
    if (selectedIds.length === Object.keys(state.sessions).length && selectedIds.length > 1) {
         deleteAllSessions(); // Redirect to delete all confirmation
         return;
    }


    showCustomConfirm(`Bạn có chắc muốn xóa ${selectedIds.length} phiên đã chọn không?`, () => {
        let wasCurrentSessionDeleted = false;
        selectedIds.forEach(id => {
            if (id === state.currentSessionId) {
                wasCurrentSessionDeleted = true;
            }
            delete state.sessions[id];
        });

        if (wasCurrentSessionDeleted) {
            // Find the newest remaining session to load
            const remainingKeys = Object.keys(state.sessions).sort((a, b) => parseInt(b.split('-')[1] || 0) - parseInt(a.split('-')[1] || 0));
            if (remainingKeys.length > 0) {
                state.currentSessionId = remainingKeys[0];
                loadSession(state.currentSessionId);
            } else {
                // This should not happen due to the check above, but as a fallback:
                createNewSession();
            }
        }
        saveSessions();
        updateSessionSelector(); // Update selector first
        if (!wasCurrentSessionDeleted) { // Only update main UI if current session wasn't deleted
             updateAllUI();
        }
        showToast(`Đã xóa ${selectedIds.length} phiên.`, 'success');
    });
}
function deleteAllSessions() {
    showCustomConfirm('BẠN CÓ CHẮC MUỐN XÓA TẤT CẢ CÁC PHIÊN KHÔNG? Hành động này không thể hoàn tác.', () => {
        state.sessions = {};
        state.currentSessionId = null;
        localStorage.removeItem('baccaratCongPhuc_v1');
        localStorage.removeItem('lastActiveCongPhuc_v1');
        createNewSession(); // Create a fresh session
        showToast('Tất cả các phiên đã được xóa.', 'success');
    });
}
function loadSession(sessionId) {
    if (state.sessions[sessionId]) {
        state.currentSessionId = sessionId;
        // Reset current predictions when loading
        state.currentPredictions = { sys1: null, sys2: null, sys3: null };
        state.originalSystemPredictions = { sys1: null, sys2: null, sys3: null };
        state.currentFinalPredictions = { sys1: null, sys2: null, sys3: null };
        state.currentChotPredictionsForLog = { sys1: null, sys2: null, sys3: null };
        localStorage.setItem('lastActiveCongPhuc_v1', state.currentSessionId);
        updateSessionSelector(); // Ensure selector highlights correctly
        updateAllUI(); // Calculate and display for the loaded session
    } else {
        showToast(`Không tìm thấy phiên với ID: ${sessionId}`, "error");
        // Optionally load the newest session or create one
        initializeApp(); // Re-initialize to handle error state
    }
}

// --- IMPORT / EXPORT & RECALCULATION ---

// Recalculates all predictions based *only* on imported history
function runRecalculation(importedSessions) {
    state.sessions = {}; // Clear current state
    state.currentSessionId = null;
    localStorage.removeItem('baccaratCongPhuc_v1');
    localStorage.removeItem('lastActiveCongPhuc_v1');

    const sortedSessionIds = Object.keys(importedSessions).sort((a, b) => {
        const timeA = parseInt(a.split('-')[1] || 0);
        const timeB = parseInt(b.split('-')[1] || 0);
        return timeA - timeB; // Process oldest first
    });

    // Keep track of the sessions state as it's being rebuilt for historical lookups
    let rebuiltSessions = {};

    sortedSessionIds.forEach(sessionId => {
        const importedSession = importedSessions[sessionId];
        if (!importedSession || !importedSession.name || !Array.isArray(importedSession.history)) {
            console.warn(`Skipping invalid imported session: ${sessionId}`);
            return;
        }

        const newId = sessionId;
        // Create the session structure first
        rebuiltSessions[newId] = {
            name: importedSession.name,
            history: [], // Start empty, will be populated
            systemData: {
                sys1: { predictions: [], verdictPredictions: [], chotPredictions: [], lengthPerformance: {}, optimalLength: null, chotLengthPerformance: CHOT_SOURCES.reduce((acc, key) => { acc[key] = {}; return acc; }, {}), chotOptimalLengths: CHOT_SOURCES.reduce((acc, key) => { acc[key] = null; return acc; }, {}) },
                sys2: { predictions: [], verdictPredictions: [], chotPredictions: [], lengthPerformance: {}, optimalLength: null, chotLengthPerformance: CHOT_SOURCES.reduce((acc, key) => { acc[key] = {}; return acc; }, {}), chotOptimalLengths: CHOT_SOURCES.reduce((acc, key) => { acc[key] = null; return acc; }, {}) },
                sys3: { predictions: [], verdictPredictions: [], chotPredictions: [], lengthPerformance: {}, optimalLength: null, chotLengthPerformance: CHOT_SOURCES.reduce((acc, key) => { acc[key] = {}; return acc; }, {}), chotOptimalLengths: CHOT_SOURCES.reduce((acc, key) => { acc[key] = null; return acc; }, {}) }
            }
        };

        // Process history step-by-step to recalculate state
        importedSession.history.forEach((result) => {
             if (result === 'P' || result === 'B') {
                 const currentHistory = rebuiltSessions[newId].history;
                 let tempPredictions = {};
                 let tempOriginalPredictions = {};
                 let tempFinalPredictions = {};
                 let tempChotPredictions = {};

                 // Calculate predictions for EACH system based on currentHistory
                  updateGlobalConfidenceSequenceData(); // Update sequences based on rebuiltSessions up to this point
                 for (const systemKey in state.matchers) {
                     const sessionSystemData = rebuiltSessions[newId].systemData[systemKey];
                     const matcher = state.matchers[systemKey];
                     const { prediction, confidence, isCertain } = matcher.getPrediction(currentHistory, rebuiltSessions, sessionSystemData);
                     tempPredictions[systemKey] = { prediction, confidence };
                     tempOriginalPredictions[systemKey] = prediction;

                     const finalVerdict = getFinalVerdict(systemKey); // Needs access to global sequence data
                      let finalPredictionForDisplay = prediction;
                      if (finalVerdict.verdict === 'against' && !isCertain) {
                          finalPredictionForDisplay = prediction === 'P' ? 'B' : 'P';
                      }
                      tempFinalPredictions[systemKey] = { verdict: finalVerdict.verdict, prediction: finalPredictionForDisplay };

                      // Calculate Chot prediction (requires complex state, simulate it)
                      // This needs the logic from updateChotAnalysisUI simplified to just get the prediction
                      tempChotPredictions[systemKey] = calculateSingleChotPredictionForRecalc(systemKey, tempOriginalPredictions[systemKey], tempFinalPredictions[systemKey], tempPredictions[systemKey]?.confidence, rebuiltSessions, newId, sessionSystemData);

                 } // End loop for systems

                 // NOW, add the result and log the predictions that were just calculated
                 rebuiltSessions[newId].history.push(result);
                 for (const systemKey in state.matchers) {
                     const systemData = rebuiltSessions[newId].systemData[systemKey];

                     const corePred = tempPredictions[systemKey];
                     if (corePred && corePred.prediction) {
                         systemData.predictions.push({ predicted: corePred.prediction, actual: result, confidence: corePred.confidence });
                     }

                     const finalPred = tempFinalPredictions[systemKey];
C                    if (finalPred && finalPred.prediction) {
                         systemData.verdictPredictions.push({ verdict: finalPred.verdict, predicted: finalPred.prediction, actual: result });
                     }

                     const chotPred = tempChotPredictions[systemKey];
                      if (chotPred && chotPred.prediction) { // Check chotPred itself exists
                           systemData.chotPredictions.push({ predicted: chotPred.prediction, actual: result, source: chotPred.source || 'CHOT_VOTE'});
                      } else {
                           systemData.chotPredictions.push({ predicted: null, actual: result, source: 'None'});
                      }


                      // Update performance metrics
                       // <<< FIX: Pass systemKey to the function
                       const newOptimalLength = updateLengthPerformanceAndFindOptimal(systemData, systemKey, currentHistory, rebuiltSessions, result); // Pass current systemData
                       systemData.optimalLength = newOptimalLength;
                       updateChotLengthPerformance(rebuiltSessions[newId], systemKey, tempOriginalPredictions[systemKey], result);

                 }
             } else {
                  console.warn(`Skipping invalid result '${result}' during recalculation in session ${newId}`);
t            }
        }); // End history loop
    }); // End session loop

     // Helper function for runRecalculation to get Chot vote result
     function calculateSingleChotPredictionForRecalc(systemKey, originalSystemPB, finalVerdictInfo, currentConfidence, allHistoricalSessions, currentSessionId, sessionSystemData) {
         const activeSourcesKeys = new Set();
         const finalVotesPB = { P: 0, B: 0 };
         let finalChotPB = null;

         if (originalSystemPB && finalVerdictInfo !== null) {
             if (finalVerdictInfo.verdict === 'follow') activeSourcesKeys.add('follow');
             else if (finalVerdictInfo.verdict === 'against') activeSourcesKeys.add('against');
             const activeConfidenceRange = CONFIDENCE_RANGES.find(r => currentConfidence >= r.min && currentConfidence < r.max);
             if (activeConfidenceRange) activeSourcesKeys.add(activeConfidenceRange.key);

             const allSequences = getChotAnalysisData(); // Uses current global state (might need adjustment)

             for (const sourceKey of CHOT_SOURCES) {
                 const isActive = activeSourcesKeys.has(sourceKey);
                 const currentSequence = allSequences[sourceKey]?.[currentSessionId] || "";
                 const historicalData = { ...allSequences[sourceKey] };
                  if(historicalData) delete historicalData[currentSessionId];

                 const analysisResult = getChotPrediction(currentSequence, historicalData, sourceKey, sessionSystemData);
                 let voteFor = null;
                 if (isActive && analysisResult.predictedWL) {
                     const predictedWL = analysisResult.predictedWL;
                     if (sourceKey === 'against') {
                          voteFor = (predictedWL === 'W') ? (originalSystemPB === 'P' ? 'B' : 'P') : originalSystemPB;
                     } else {
                          voteFor = (predictedWL === 'W') ? originalSystemPB : (originalSystemPB === 'P' ? 'B' : 'P');
                     }
                      finalVotesPB[voteFor]++;
                 }
             }

             const totalVotes = finalVotesPB.P + finalVotesPB.B;
             if (totalVotes > 0) {
                  if (finalVotesPB.P > finalVotesPB.B) finalChotPB = 'P';
                  else if (finalVotesPB.B > finalVotesPB.P) finalChotPB = 'B';
                  // Keep null if tie
             }
         }
         return { prediction: finalChotPB, source: 'CHOT_VOTE' }; // Return format consistent with logging
     }


    // After processing all sessions, set the state
    state.sessions = rebuiltSessions;

    // Load the last session or create new
    if (Object.keys(state.sessions).length > 0) {
        const lastProcessedId = Object.keys(state.sessions).sort((a, b) => parseInt(a.split('-')[1] || 0) - parseInt(b.split('-')[1] || 0)).pop();
        loadSession(lastProcessedId);
    } else {
        createNewSession();
    }
    updateSessionSelector();
    updateAllUI(); // Update UI based on the fully recalculated state
}

// Import data (only history and name)
function importData(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const importedSessions = JSON.parse(e.target.result);
            // Basic validation
            if (typeof importedSessions !== 'object' || importedSessions === null) throw new Error("File không đúng định dạng.");
            let dataOk = true;
            for(const key in importedSessions) {
                if(!importedSessions[key].name || !Array.isArray(importedSessions[key].history)) {
                    dataOk = false; break;
                };
            }
            if (!dataOk && Object.keys(importedSessions).length > 0) throw new Error("Dữ liệu phiên không hợp lệ.");

            showCustomConfirm('Dữ liệu hiện tại sẽ bị ghi đè. Lịch sử sẽ được nhập và tất cả dự đoán sẽ được TÍNH TOÁN LẠI. Tiếp tục?', () => {
                showLoadingModal('Đang nhập và tính toán lại...');
                setTimeout(() => { // Allow modal to render
                    try {
                        runRecalculation(importedSessions); // Use the recalculation function
                    _   showToast('Nhập và tính toán lại thành công!', 'success');
                    } catch (calcError) {
                        hideLoadingModal();
                        showToast(`Lỗi khi tính toán lại: ${calcError.message}`, 'error');
                        console.error("Recalculation error:", calcError);
                        initializeApp(); // Reset on error
                    }
                }, 100);
            });
        } catch (error) {
            hideLoadingModal();
            showToast(`Lỗi đọc hoặc phân tích file: ${error.message}`, 'error');
            console.error("Import error:", error);
        } finally {
            event.target.value = ''; // Clear file input
        }
    };
    reader.onerror = function() {
        hideLoadingModal();
        showToast('Lỗi đọc file.', 'error');
        event.target.value = '';
    };
    reader.readAsText(file);
}

// Export data (only history and name)
function exportData() {
    if (!state.sessions || Object.keys(state.sessions).length === 0) {
        showToast('Không có dữ liệu để xuất.', 'warning');
        return;
    }
    const sessionsToExport = {};
    for(const sessionId in state.sessions) {
        sessionsToExport[sessionId] = {
            name: state.sessions[sessionId].name,
            history: state.sessions[sessionId].history
        };
    }
    const dataStr = JSON.stringify(sessionsToExport, null, 2);
    const blob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const now = new Date();
    const day = String(now.getDate()).padStart(2, '0');
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const year = now.getFullYear();
    a.download = `LỊCH SỬ NGÀY ${day} THÁNG ${month} NĂM ${year}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showToast('Xuất lịch sử thành công!', 'success');
}


// --- CUSTOM UI COMPONENTS (MODAL, TOAST, PROMPT) ---
// (Keep these functions as they are generally useful)
function showToast(message, type = 'info') {
    const container = document.getElementById('toast-container');
    if (!container) return; // Add check
    const toast = document.createElement('div');
    const colors = { success: 'border-green-500', info: 'border-blue-500', warning: 'border-yellow-500', error: 'border-red-500' };
    toast.className = `toast-notification ${colors[type] || 'border-gray-500'}`;
    toast.textContent = message;
    container.appendChild(toast);
    setTimeout(() => {
        toast.style.animation = 'fadeOut 0.5s ease forwards'; // Use forwards to keep final state
        setTimeout(() => toast.remove(), 500);
    }, 3000);
}
function showLoadingModal(message) {
    const container = document.getElementById('modal-container');
     if (!container) return;
    container.innerHTML = `
    <div id="loading-modal" class="modal-backdrop">
        <div class="modal-content text-center">
            <p class="text-lg text-gray-200">${message}</p>
            <div class="mt-4">
                <svg class="animate-spin h-8 w-8 text-white mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
            </div>
        </div>
    </div>`;
}
function hideLoadingModal() {
    const modal = document.getElementById('loading-modal');
    const container = document.getElementById('modal-container');
     if (!container) return;
    if (modal) {
        modal.style.animation = 'fadeOut 0.3s ease forwards';
        setTimeout(() => { if (container.contains(modal)) container.innerHTML = ''; }, 300);
t   } else {
        container.innerHTML = ''; // Clear if modal not found but container exists
    }
}
function showCustomConfirm(message, onConfirm) {
    const container = document.getElementById('modal-container');
     if (!container) return;
    const modalId = `custom-confirm-${Date.now()}`; // Unique ID
    const modalHTML = `
    <div id="${modalId}" class="modal-backdrop">
        <div class="modal-content">
            <p class="text-lg text-gray-200 mb-6">${message}</p>
            <div class="flex justify-end gap-4">
                <button id="${modalId}-cancel" class="btn bg-gray-600 hover:bg-gray-500 px-6 py-2 rounded-lg">Hủy</button>
                <button id="${modalId}-ok" class="btn bg-red-600 hover:bg-red-500 px-6 py-2 rounded-lg">Xác nhận</button>
            </div>
        </div>
    </div>`;
    container.innerHTML = modalHTML; // Replace content

    const modalElement = document.getElementById(modalId);
    const closeConfirm = (confirmed) => {
         if(!modalElement) return;
         modalElement.style.animation = 'fadeOut 0.3s ease forwards';
         setTimeout(() => {
              if (container.contains(modalElement)) container.innerHTML = ''; // Clear only if it's still there
              if (confirmed) onConfirm();
          }, 300);
    };

    document.getElementById(`${modalId}-ok`).onclick = () => closeConfirm(true);
    document.getElementById(`${modalId}-cancel`).onclick = () => closeConfirm(false);
}
function showCustomPrompt(message, defaultValue, onConfirm) {
    const container = document.getElementById('modal-container');
     if (!container) return;
    const modalId = `custom-prompt-${Date.now()}`;
    const modalHTML = `
    <div id="${modalId}" class="modal-backdrop">
        <div class="modal-content">
            <p class="text-lg text-gray-200 mb-4">${message}</p>
            <input type="text" id="${modalId}-input" value="${defaultValue}" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none mb-6">
          _ <div class="flex justify-end gap-4">
                <button id="${modalId}-cancel" class="btn bg-gray-600 hover:bg-gray-500 px-6 py-2 rounded-lg">Hủy</button>
                <button id="${modalId}-ok" class="btn bg-blue-600 hover:bg-blue-500 px-6 py-2 rounded-lg">Lưu</button>
            </div>
        </div>
    </div>`;
    container.innerHTML = modalHTML;

    const modalElement = document.getElementById(modalId);
    const input = document.getElementById(`${modalId}-input`);
    input.focus();
    input.select();

    const closePrompt = (value) => {
         if(!modalElement) return;
        modalElement.style.animation = 'fadeOut 0.3s ease forwards';
        setTimeout(() => {
             if (container.contains(modalElement)) container.innerHTML = '';
            if (value !== null) onConfirm(value); // Pass value only if confirmed
        }, 300);
    };

    document.getElementById(`${modalId}-ok`).onclick = () => closePrompt(input.value);
    document.getElementById(`${modalId}-cancel`).onclick = () => closePrompt(null); // Pass null on cancel
    input.onkeydown = (e) => { if (e.key === 'Enter') document.getElementById(`${modalId}-ok`).click(); };
}


// --- INITIALIZATION ---
function initializeApp() {
    state.sessions = getSessions(); // Load and validate sessions
    const lastActiveId = localStorage.getItem('lastActiveCongPhuc_v1');

    if (Object.keys(state.sessions).length === 0) {
        createNewSession(); // Creates first session if none exist
    } else {
        // Load last active session, or the newest one if last active is invalid
        const sortedKeys = Object.keys(state.sessions).sort((a, b) => parseInt(a.split('-')[1] || 0) - parseInt(b.split('-')[1] || 0));
        const idToLoad = (lastActiveId && state.sessions[lastActiveId]) ? lastActiveId : sortedKeys[sortedKeys.length - 1];
        state.currentSessionId = idToLoad;
        loadSession(idToLoad); // Load session data and update UI
    }

    // Ensure session management is initially collapsed
    const sessionContent = document.getElementById('sessionManagementContent');
    const sessionIcon = document.getElementById('toggleSessionIcon');
  "   if(sessionContent) sessionContent.style.maxHeight = '0px';
    if(sessionIcon) sessionIcon.style.transform = 'rotate(-180deg)';
}

document.addEventListener('DOMContentLoaded', initializeApp);
</script>

</body>
</html>
